using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using VENative.Blazor.ServiceGenerator.Extensions;
using static System.String;

namespace VENative.Blazor.ServiceGenerator;

[Generator]
public class ClientImplementationGenerator : IIncrementalGenerator
{
    const string CANCELLATION_TOKEN = "System.Threading.CancellationToken";
    const string CLIENT_ATTRIBUTE = "VENative.Blazor.ServiceGenerator.Attributes.GenerateClientAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
#if DEBUG
        //if (!Debugger.IsAttached)
        //{
        //    Debugger.Launch();
        //}
#endif

        var compilationProvider = context.CompilationProvider;

        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsInterfaceWithAttributes(node),
                transform: static (context, _) => HasRequiredAttribute(context))
            .Where(static symbol => symbol is not null)
            .Collect();

        var combined = compilationProvider.Combine(classDeclarations);

        context.RegisterSourceOutput(combined, (spc, source) => Execute(spc, source.Left, source.Right));
    }

    private static bool IsInterfaceWithAttributes(SyntaxNode node)
    {
        return node is InterfaceDeclarationSyntax interfaceDeclaration && interfaceDeclaration.AttributeLists.Count > 0;
    }

    private static INamedTypeSymbol? HasRequiredAttribute(GeneratorSyntaxContext context)
    {
        var classDeclaration = (InterfaceDeclarationSyntax)context.Node;
        var semanticModel = context.SemanticModel;
        var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration);
        var attributes = classSymbol?.GetAttributes();

        if (attributes?.Any(a => a.AttributeClass?.ToDisplayString() == CLIENT_ATTRIBUTE) == true)
        {
            return classSymbol;
        }
        return null;
    }

    private static void Execute(SourceProductionContext context, Compilation compilation, ImmutableArray<INamedTypeSymbol?> interfaces)
    {
        if (interfaces.IsDefaultOrEmpty)
            return;

        var candidates = compilation.GetTypeByMetadataName(CLIENT_ATTRIBUTE);

        foreach (var interfaceSymbol in interfaces)
        {
            if (interfaceSymbol != null && interfaceSymbol.GetAttributes()
                .Any(attr => SymbolEqualityComparer.Default.Equals(attr.AttributeClass, candidates)))
            {
                GenerateClass(context, compilation, interfaceSymbol);
            }
        }
    }

    private static void GenerateClass(SourceProductionContext context, Compilation compilation, INamedTypeSymbol interfaceSymbol)
    {
        var clientAttributeSymbol = compilation.GetTypeByMetadataName(CLIENT_ATTRIBUTE);
        var interfaceName = interfaceSymbol.Name;

        if (clientAttributeSymbol is null)
        {
            ReportError(context, "SG0001", $"Attribute '{CLIENT_ATTRIBUTE}' not found.");
            return;
        }

        var attributeData = interfaceSymbol.GetAttributes()
            .First(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, clientAttributeSymbol));

        var @namespace = (string)attributeData.ConstructorArguments[0].Value!;
        var @route = (string)attributeData.ConstructorArguments[1].Value!;
        var @generatedClassPrefix = (string)attributeData.ConstructorArguments[2].Value!;
        var @generatedClassName = (string?)attributeData.ConstructorArguments[3].Value ?? interfaceSymbol.Name;

        @generatedClassPrefix = @generatedClassPrefix.Replace("{interfaceName}", interfaceName);

        @generatedClassName = @generatedClassName.Replace("{interfaceName}", interfaceName)
            .Replace("{generatedClassPrefix}", @generatedClassPrefix);

        @namespace = @namespace.Replace("{interfaceNamespace}", interfaceSymbol.ContainingNamespace.ToDisplayString())
            .Replace("{interfaceName}", interfaceName)
            .Replace("{generatedClassName}", @generatedClassName)
            .Replace("{generatedClassPrefix}", @generatedClassPrefix);

        @route = @route.Replace("{interfaceName}", interfaceName)
            .Replace("{generatedClassName}", @generatedClassName)
            .Replace("{generatedClassPrefix}", @generatedClassPrefix);

        string source =
        $$"""
        // <auto-generated>
        // This file was generated by the ClientImplementationGenerator.
        // Any changes made to this file will be overwritten.
        // </auto-generated>

        #nullable enable

        using System;
        using System.Web;
        using System.Net.Http;
        using System.Threading;
        using Microsoft.JSInterop;
        using System.Threading.Tasks;
        using Microsoft.AspNetCore.SignalR;
        using Microsoft.AspNetCore.Components;
        using Microsoft.AspNetCore.SignalR.Client;
        using Microsoft.Extensions.DependencyInjection;

        namespace {{@namespace}};

        [Route("{{@route}}")]
        public class {{@generatedClassName}} : {{interfaceName}}, IAsyncDisposable
        {
            private readonly HubConnection _hubConnection;
            private readonly NavigationManager _nm;
            private readonly IServiceProvider _sp;
            private readonly IJSInProcessRuntime _js;
            private const string CALLER = "{{@namespace}}.{{@generatedClassName}}[0]";

            public {{@generatedClassName}}(IJSRuntime js, IServiceProvider sp, NavigationManager navigationManager)
            {
                var absoluteUri = new Uri(new Uri(navigationManager.BaseUri), "{{interfaceName}}");

                _js = (IJSInProcessRuntime)js;
                _sp = sp;
                _nm = navigationManager;
                _hubConnection = new HubConnectionBuilder()
                    .WithUrl(absoluteUri)
                    .WithAutomaticReconnect()
                    .WithServerTimeout(TimeSpan.FromHours(1))
                    .Build();
                LogDebug("Endpoint URI: " + absoluteUri);
            }
      
            public class InfiniteRetryPolicy : IRetryPolicy
            {
                public TimeSpan? NextRetryDelay(RetryContext retryContext)
                {
                    return TimeSpan.FromSeconds(5);
                }
            }

            private void LogError(string message)
            {
                _js.InvokeVoid("console.error", CALLER + ": " + message);
            }

            private void LogError(Exception ex, string message)
            {
                _js.InvokeVoid("console.error", CALLER + ": " + ex.Message  + " | " + message);
            }

            private void LogDebug(string message)
            {
                _js.InvokeVoid("console.debug", CALLER + ": " + message);
            }

            private async Task HandleUnauthorized()
            {
                var encodedUrl = HttpUtility.UrlEncode(_nm.Uri);
                _nm.NavigateTo("Account/Login?returnUrl=" + encodedUrl, true);
                await Task.Delay(Timeout.Infinite);
            }

            private async Task HandleHttpRequestException(HttpRequestException ex)
            {
                LogDebug("HandleHttpRequestException");
                if (ex.StatusCode == System.Net.HttpStatusCode.Unauthorized)
                {
                    await HandleUnauthorized();
                }
                else 
                {
                    LogError("Error: " + ex.Message);
                }
            }

            private async Task<bool> EnsureConnectionAsync()
            {
                LogDebug("EnsureConnectionAsync");
                if (_hubConnection.State == HubConnectionState.Disconnected)
                {
                    try
                    {
                        LogDebug("Trying to start hub connection");
                        await _hubConnection.StartAsync();
                    }
                    catch (HttpRequestException ex)
                    {
                        LogDebug("Failed to start hub connection");
                        await HandleHttpRequestException(ex);
                    }
                }

                var isConnected = _hubConnection.State == HubConnectionState.Connected;

                if (isConnected)
                {
                    LogDebug("Hub is now connected");
                }
                else
                {
                    LogDebug("Hub is still disconnected");
                }

                return isConnected;
            }

            public async ValueTask DisposeAsync()
            {
                if (_hubConnection is not null)
                {
                    await _hubConnection.DisposeAsync();
                }
            }  
            {{GenerateMethods(interfaceSymbol)}}
        }
        """;

        var fileName = $"{@generatedClassName}.g.cs";
        context.AddSource(fileName, source);
        ReportInfo(context, "INF0001", $"The class '{fileName}' was generated");
    }

    public static string GenerateMethods(INamedTypeSymbol interfaceSymbol)
    {
        try
        {
            StringBuilder sb = new();

            foreach (var method in interfaceSymbol.GetMembers().OfType<IMethodSymbol>())
            {
                var taskReturnType = method.ReturnType.ToDisplayString();
                var fullGenericArgumentType = "";

                if (method.ReturnType is INamedTypeSymbol namedTypeSymbol && namedTypeSymbol.IsGenericType)
                {
                    foreach (var typeArgument in namedTypeSymbol.TypeArguments)
                    {
                        var genericArgumentType = typeArgument;
                        fullGenericArgumentType = genericArgumentType.ToDisplayString();
                    }
                }

                var methodName = method.Name;
                var parameters = Join(", ", method.Parameters.Select(p => $"{p.Type.ToDisplayString()} {p.Name}"));
                var parameterNames = Join(", ", method.Parameters.Select(p => p.Type.ToDisplayString() == CANCELLATION_TOKEN ? $"cancellationToken: {p.Name}" : p.Name));

                var hasCancellationToken = method.Parameters.HasCancellationToken();
                var returnsSomething = !IsNullOrWhiteSpace(fullGenericArgumentType);
                var isAsyncEnumerable = method.ReturnType.OriginalDefinition.Name == "IAsyncEnumerable";

                var returnText = returnsSomething ? "return" : null;
                var genericText = returnsSomething ? $"<{fullGenericArgumentType}>" : "<bool>";
                var methodNameText = "\"" + methodName + "\"";

                var arguments = Join(", ", methodNameText, parameterNames).TrimEnd().TrimEnd(',');
                string invocation;

                if (hasCancellationToken)
                {
                    if (isAsyncEnumerable)
                    {
                        invocation =
                        $$"""
                            var asyncEnumerable = _hubConnection.StreamAsync{{genericText}}({{arguments}});
                            await foreach (var result in asyncEnumerable)
                            {
                                yield return result;
                            }
                        """;
                    }
                    else
                    {
                        invocation =
                        $$"""
                            var asyncEnumerable = _hubConnection.StreamAsync{{genericText}}({{arguments}});
                            {{S(fullGenericArgumentType, $"{fullGenericArgumentType} retrn = default!;", null)}}
                            await foreach (var result in asyncEnumerable)
                            {
                                {{S(fullGenericArgumentType, "retrn = result;", null)}}
                                break;
                            }
                            {{S(fullGenericArgumentType, "return retrn;", null)}}
                        """;
                    }
                }
                else
                {
                    invocation = $"{returnText} await _hubConnection.InvokeAsync{genericText}({arguments});";
                }
                
                if (isAsyncEnumerable)
                {
                    parameters = Join(", ", method.Parameters.Select(p => p.Type.ToDisplayString() == CANCELLATION_TOKEN ? "[System.Runtime.CompilerServices.EnumeratorCancellation] CancellationToken cancellationToken = default" : $"{p.Type.ToDisplayString()} {p.Name}"));
                    sb.AppendLine(
                    $$"""
                        public async {{taskReturnType}} {{methodName}}({{parameters}}) 
                        {
                            await EnsureConnectionAsync();

                            {{invocation}}
                        }
                    """);
                }
                else
                {
                    sb.AppendLine(
                    $$"""

                        public async {{taskReturnType}} {{methodName}}({{parameters}})   
                        {
                            await EnsureConnectionAsync();
                
                            {{invocation}}
                        }
                    """);
                }
            }

            return sb.ToString();
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException("An error occurred while generating a method.", ex);
        }
    }

    /// <summary>
    /// Returns the value of <paramref name="whenNotNull"/> if <paramref name="value"/> is not null or empty; otherwise, <paramref name="whenNull"/>.
    /// </summary>
    /// <param name="value"></param>
    /// <param name="whenNotNull"></param>
    /// <param name="whenNull"></param>
    /// <returns></returns>
    private static string? S(string? value, string? whenNotNull, string? whenNull)
    {
        return !IsNullOrWhiteSpace(value) ? whenNotNull : whenNull;
    }

    private static void ReportError(SourceProductionContext context, string id, string message, INamedTypeSymbol? classSymbol = null)
    {
        var diagnostic = Diagnostic.Create(
            new DiagnosticDescriptor(id, "Validation Error", message, "SourceGenerator", DiagnosticSeverity.Error, true),
            classSymbol?.Locations.FirstOrDefault());
        context.ReportDiagnostic(diagnostic);
    }

    private static void ReportInfo(SourceProductionContext context, string id, string message, INamedTypeSymbol? classSymbol = null)
    {
        var diagnostic = Diagnostic.Create(
            new DiagnosticDescriptor(id, "Information", message, "SourceGenerator", DiagnosticSeverity.Info, true),
            classSymbol?.Locations.FirstOrDefault());
        context.ReportDiagnostic(diagnostic);
    }
}